"""
Unified Conversation Manager - Single source for conversation operations
Implements UUID-based message IDs and consistent conversation management
"""

import uuid
import datetime
import logging
import json
from typing import Dict, List, Optional, Any
from contextlib import contextmanager
from app.database import get_db

logger = logging.getLogger(__name__)

@contextmanager
def get_db_context():
    """Context manager for database connections to ensure closure"""
    db = get_db()
    try:
        yield db
    finally:
        db.close()

def ensure_conversation_exists(conversation_id: Optional[str], user_id: int, title: Optional[str] = None) -> str:
    """
    Ensure conversation exists, create if missing
    Returns conversation_id (new or existing)
    
    IMPORTANT: This function should NOT generate new conversation IDs.
    Conversation IDs should only be generated by the sessions endpoint.
    If no conversation_id is provided, raise an error.
    """
    with get_db_context() as db:
        if not conversation_id:
            # CRITICAL: Frontend should always provide a conversation_id from backend
            # If missing, this is a frontend bug or missing session creation
            logger.error(f"‚ùå Missing conversation_id for user {user_id}. Frontend must create session first.")
            raise ValueError("Missing conversation_id. Create a session first using /api/sessions")
        
        logger.info(f"üîç Checking existing conversation ID: {conversation_id} for user {user_id}")
        
        # Check if conversation exists
        conversation = db.execute(
            "SELECT id, title FROM conversations WHERE id = ? AND user_id = ?",
            (conversation_id, user_id)
        ).fetchone()
        
        if conversation:
            # Conversation exists, update title if provided
            if title and title != conversation[1]:
                db.execute(
                    "UPDATE conversations SET title = ?, updated_at = ? WHERE id = ?",
                    (title, datetime.datetime.now(), conversation_id)
                )
                db.commit()
                logger.info(f"üìù Updated conversation title: {conversation_id} -> {title}")
            else:
                logger.info(f"‚úÖ Conversation already exists: {conversation_id} with title: {conversation[1]}")
            return conversation_id
        
        # Create new conversation
        if not title:
            title = f"Conversation {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}"
        
        db.execute(
            "INSERT INTO conversations (id, user_id, title, created_at, updated_at, message_count, total_tokens) VALUES (?, ?, ?, ?, ?, ?, ?)",
            (conversation_id, user_id, title, datetime.datetime.now(), datetime.datetime.now(), 0, 0)
        )
        db.commit()
        
        logger.info(f"‚úÖ Created conversation {conversation_id} for user {user_id} with title: {title}")
        return conversation_id

def save_message(
    conversation_id: str, 
    user_id: int, 
    role: str, 
    content: str, 
    metadata: Optional[Dict] = None,
    model: Optional[str] = None,
    provider: Optional[str] = None
) -> Dict[str, Any]:
    """
    Save message to conversation with metadata using UUID for message ID
    Unified implementation used by all modules
    
    Args:
        conversation_id: Conversation ID
        user_id: User ID
        role: Message role (user/assistant/system)
        content: Message content
        metadata: Additional metadata (JSON)
        model: Model used for this message (default: 'gpt-3.5-turbo')
        provider: Provider used for this message (default: 'openai')
    """
    with get_db_context() as db:
        # Generate UUID for message
        message_id = str(uuid.uuid4())
        
        # Estimate tokens
        tokens = estimate_tokens(content)
        
        # Prepare metadata JSON - include provider/model if not already in metadata
        metadata_to_store = metadata or {}
        if model and "model" not in metadata_to_store:
            metadata_to_store["model"] = model
        if provider and "provider" not in metadata_to_store:
            metadata_to_store["provider"] = provider
            
        metadata_json = None
        if metadata_to_store:
            metadata_json = json.dumps(metadata_to_store)
        
        # Use provided model/provider or defaults
        model_to_store = model or "gpt-3.5-turbo"
        provider_to_store = provider or "openai"
        
        # Save message with UUID
        created_at = datetime.datetime.now()
        
        db.execute(
            "INSERT INTO messages (id, conversation_id, user_id, role, content, tokens, provider, model, metadata, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (message_id, conversation_id, user_id, role, content, tokens, provider_to_store, model_to_store, metadata_json, created_at)
        )
        
        # Update conversation
        db.execute(
            "UPDATE conversations SET message_count = message_count + 1, total_tokens = total_tokens + ?, updated_at = ? WHERE id = ?",
            (tokens, created_at, conversation_id)
        )
        
        db.commit()
        
        result = {
            "id": message_id,
            "conversation_id": conversation_id,
            "role": role,
            "content": content,
            "tokens": tokens,
            "model": model_to_store,
            "provider": provider_to_store,
            "metadata": metadata_to_store,
            "created_at": created_at
        }
        
        logger.info(f"‚úÖ Saved message to conversation {conversation_id}, role: {role}, model: {model_to_store}, provider: {provider_to_store}, tokens: {tokens}")
        return result

def save_reasoning_session(session_id: str, conversation_id: str, metadata: Optional[Dict] = None) -> bool:
    """Save a reasoning session to the database"""
    try:
        with get_db_context() as db:
            metadata_json = json.dumps(metadata) if metadata else None
            
            db.execute(
                "INSERT OR REPLACE INTO reasoning_sessions (id, conversation_id, metadata) VALUES (?, ?, ?)",
                (session_id, conversation_id, metadata_json)
            )
            db.commit()
            return True
    except Exception as e:
        logger.error(f"‚ùå Failed to save reasoning session {session_id}: {str(e)}")
        return False

def save_reasoning_step(session_id: str, step_data: Dict[str, Any]) -> bool:
    """Save a reasoning step to the database"""
    try:
        with get_db_context() as db:
            step_index = step_data.get("index", 0)
            step_type = step_data.get("step_type")
            title = step_data.get("title")
            content = step_data.get("content", "")
            metadata = step_data.get("metadata")
            metadata_json = json.dumps(metadata) if metadata else None
            
            db.execute(
                "INSERT INTO reasoning_steps (session_id, step_index, step_type, title, content, metadata) VALUES (?, ?, ?, ?, ?, ?)",
                (session_id, step_index, step_type, title, content, metadata_json)
            )
            db.commit()
            return True
    except Exception as e:
        logger.error(f"‚ùå Failed to save reasoning step for session {session_id}: {str(e)}")
        return False

def get_reasoning_steps(session_id: str) -> List[Dict[str, Any]]:
    """Get reasoning steps for a session"""
    with get_db_context() as db:
        steps = db.execute(
            "SELECT step_index, step_type, title, content, metadata, timestamp FROM reasoning_steps WHERE session_id = ? ORDER BY step_index ASC",
            (session_id,)
        ).fetchall()
        
        result = []
        for s in steps:
            step_data = {
                "index": s[0],
                "step_type": s[1],
                "title": s[2],
                "content": s[3],
                "timestamp": s[5]
            }
            if s[4]:
                try:
                    step_data["metadata"] = json.loads(s[4])
                except:
                    step_data["metadata"] = {}
            else:
                step_data["metadata"] = {}
            result.append(step_data)
        
        return result

def get_conversation_messages(conversation_id: str, limit: Optional[int] = None) -> List[Dict[str, Any]]:
    """
    Get messages for a conversation
    """
    with get_db_context() as db:
        query = """
            SELECT id, role, content, tokens, metadata, created_at 
            FROM messages 
            WHERE conversation_id = ? 
            ORDER BY created_at ASC
        """
        
        if limit:
            query += " LIMIT ?"
            messages = db.execute(query, (conversation_id, limit)).fetchall()
        else:
            messages = db.execute(query, (conversation_id,)).fetchall()
        
        result = []
        for msg in messages:
            message_data = {
                "id": msg[0],
                "role": msg[1],
                "content": msg[2],
                "tokens": msg[3],
                "created_at": msg[5]
            }
            
            # Parse metadata if available
            if msg[4]:
                try:
                    metadata = json.loads(msg[4])
                    message_data["metadata"] = metadata
                except:
                    message_data["metadata"] = {}
            else:
                message_data["metadata"] = {}
            
            result.append(message_data)
        
        logger.info(f"‚úÖ Retrieved {len(result)} messages for conversation {conversation_id}")
        return result

def get_last_n_messages(conversation_id: str, n: int = 10) -> List[Dict[str, Any]]:
    """
    Get last N messages from conversation (UI history)
    """
    with get_db_context() as db:
        messages = db.execute(
            "SELECT role, content, created_at FROM messages WHERE conversation_id = ? ORDER BY created_at DESC LIMIT ?",
            (conversation_id, n)
        ).fetchall()
        
        # Return in chronological order
        return [
            {"role": msg[0], "content": msg[1], "created_at": msg[2]}
            for msg in reversed(messages)
        ]

def get_user_conversations(user_id: int, limit: Optional[int] = None, state: str = "active") -> List[Dict[str, Any]]:
    """
    Get all conversations for a user with optional state filter
    """
    with get_db_context() as db:
        query = """
            SELECT id, title, created_at, updated_at, message_count, total_tokens, state 
            FROM conversations 
            WHERE user_id = ? AND state = ?
            ORDER BY updated_at DESC
        """
        
        params = [user_id, state]
        
        if limit:
            query += " LIMIT ?"
            params.append(limit)
        
        conversations = db.execute(query, params).fetchall()
        
        result = []
        for conv in conversations:
            result.append({
                "id": conv[0],
                "title": conv[1],
                "created_at": conv[2],
                "updated_at": conv[3],
                "message_count": conv[4],
                "total_tokens": conv[5],
                "state": conv[6]
            })
        
        logger.info(f"‚úÖ Retrieved {len(result)} conversations for user {user_id} (state: {state})")
        return result

def update_conversation_title(conversation_id: str, title: str):
    """
    Update conversation title
    """
    with get_db_context() as db:
        db.execute(
            "UPDATE conversations SET title = ?, updated_at = ? WHERE id = ?",
            (title, datetime.datetime.now(), conversation_id)
        )
        db.commit()
        
        logger.info(f"‚úÖ Updated conversation title: {conversation_id} -> {title}")

def archive_conversation(conversation_id: str, user_id: int) -> bool:
    """
    Archive a conversation
    """
    try:
        with get_db_context() as db:
            result = db.execute(
                "UPDATE conversations SET state = 'archived', updated_at = ? WHERE id = ? AND user_id = ?",
                (datetime.datetime.now(), conversation_id, user_id)
            )
            db.commit()
            
            if result.rowcount > 0:
                logger.info(f"‚úÖ Archived conversation: {conversation_id}")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Conversation {conversation_id} not found or doesn't belong to user {user_id}")
                return False
            
    except Exception as e:
        logger.error(f"‚ùå Failed to archive conversation {conversation_id}: {str(e)}")
        return False

def restore_conversation(conversation_id: str, user_id: int) -> bool:
    """
    Restore an archived conversation
    """
    try:
        with get_db_context() as db:
            result = db.execute(
                "UPDATE conversations SET state = 'active', updated_at = ? WHERE id = ? AND user_id = ?",
                (datetime.datetime.now(), conversation_id, user_id)
            )
            db.commit()
            
            if result.rowcount > 0:
                logger.info(f"‚úÖ Restored conversation: {conversation_id}")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Conversation {conversation_id} not found or doesn't belong to user {user_id}")
                return False
            
    except Exception as e:
        logger.error(f"‚ùå Failed to restore conversation {conversation_id}: {str(e)}")
        return False

def delete_conversation(conversation_id: str, user_id: int) -> bool:
    """
    Delete conversation and associated data
    """
    try:
        with get_db_context() as db:
            # Verify conversation belongs to user
            conversation = db.execute(
                "SELECT id FROM conversations WHERE id = ? AND user_id = ?",
                (conversation_id, user_id)
            ).fetchone()
            
            if not conversation:
                logger.warning(f"‚ö†Ô∏è Conversation {conversation_id} not found or doesn't belong to user {user_id}")
                return False
            
            # Delete messages
            db.execute("DELETE FROM messages WHERE conversation_id = ?", (conversation_id,))
            
            # Delete file references
            db.execute("DELETE FROM file_references WHERE conversation_id = ?", (conversation_id,))
            
            # Delete conversation
            db.execute("DELETE FROM conversations WHERE id = ?", (conversation_id,))
            
            db.commit()
            
            logger.info(f"‚úÖ Deleted conversation: {conversation_id}")
            return True
        
    except Exception as e:
        logger.error(f"‚ùå Failed to delete conversation {conversation_id}: {str(e)}")
        return False

def get_conversation_stats(conversation_id: str) -> Dict[str, Any]:
    """
    Get conversation statistics
    """
    with get_db_context() as db:
        # Get conversation data
        conversation = db.execute(
            "SELECT message_count, total_tokens, created_at, updated_at, state FROM conversations WHERE id = ?",
            (conversation_id,)
        ).fetchone()
        
        if not conversation:
            return {
                "message_count": 0,
                "total_tokens": 0,
                "created_at": None,
                "updated_at": None,
                "state": None,
                "file_count": 0
            }
        
        # Get file count
        file_count = db.execute(
            "SELECT COUNT(*) FROM file_references WHERE conversation_id = ?",
            (conversation_id,)
        ).fetchone()[0]
        
        return {
            "message_count": conversation[0],
            "total_tokens": conversation[1],
            "created_at": conversation[2],
            "updated_at": conversation[3],
            "state": conversation[4],
            "file_count": file_count
        }

def estimate_tokens(text: str) -> int:
    """Accurate token estimation"""
    try:
        import tiktoken
        tokenizer = tiktoken.get_encoding("cl100k_base")
        return len(tokenizer.encode(text))
    except ImportError:
        # Fallback: rough estimation based on words
        return int(len(text.split()) * 1.3)

def get_conversation_summary(conversation_id: str) -> Optional[str]:
    """
    Get conversation summary from conversation_summaries table
    """
    with get_db_context() as db:
        result = db.execute(
            "SELECT summary FROM conversation_summaries WHERE conversation_id = ?",
            (conversation_id,)
        ).fetchone()
        
        return result[0] if result else None

def save_conversation_summary(conversation_id: str, summary: str) -> bool:
    """
    Save or update conversation summary
    """
    try:
        with get_db_context() as db:
            db.execute(
                "INSERT OR REPLACE INTO conversation_summaries (conversation_id, summary, updated_at) VALUES (?, ?, ?)",
                (conversation_id, summary, datetime.datetime.now())
            )
            db.commit()
            logger.info(f"‚úÖ Saved summary for conversation {conversation_id}")
            return True
    except Exception as e:
        logger.error(f"‚ùå Failed to save summary for conversation {conversation_id}: {str(e)}")
        return False

def should_summarize_conversation(conversation_id: str, threshold: int = 2000) -> bool:
    """
    Check if conversation should be summarized based on UN-SUMMARIZED token count.
    Threshold default is 2000 tokens (approx 1500 words).
    """
    try:
        with get_db_context() as db:
            # Get last summary time
            summary = db.execute(
                "SELECT updated_at FROM conversation_summaries WHERE conversation_id = ?",
                (conversation_id,)
            ).fetchone()
            
            last_summary_time = summary[0] if summary else None
            
            # Count tokens of messages since last summary
            if last_summary_time:
                result = db.execute(
                    "SELECT SUM(tokens) FROM messages WHERE conversation_id = ? AND created_at > ?",
                    (conversation_id, last_summary_time)
                ).fetchone()
            else:
                result = db.execute(
                    "SELECT SUM(tokens) FROM messages WHERE conversation_id = ?",
                    (conversation_id,)
                ).fetchone()
                
            token_count = result[0] if result and result[0] else 0
            
            # Also summarize if it's the first time and we have > 500 tokens (approx 10 messages)
            # to avoid waiting too long for the first summary
            if not last_summary_time and token_count > 500:
                return True
                
            return token_count > threshold
    except Exception as e:
        logger.error(f"‚ùå Failed to check summarization for conversation {conversation_id}: {str(e)}")
        return False

def get_recent_messages_for_summarization(conversation_id: str, limit: int = 20) -> List[Dict[str, Any]]:
    """
    Get recent messages for summarization.
    Kept for backward compatibility, but delegates to get_unsummarized_messages if appropriate?
    No, just keep it as utility.
    """
    try:
        with get_db_context() as db:
            messages = db.execute(
                "SELECT role, content FROM messages WHERE conversation_id = ? ORDER BY created_at DESC LIMIT ?",
                (conversation_id, limit)
            ).fetchall()
            
            # Return in chronological order
            return [
                {"role": msg[0], "content": msg[1]}
                for msg in reversed(messages)
            ]
    except Exception as e:
        logger.error(f"‚ùå Failed to get messages for summarization: {str(e)}")
        return []

def get_unsummarized_messages(conversation_id: str) -> List[Dict[str, Any]]:
    """Get messages that haven't been summarized yet"""
    try:
        with get_db_context() as db:
            # Get last summary time
            summary = db.execute(
                "SELECT updated_at FROM conversation_summaries WHERE conversation_id = ?",
                (conversation_id,)
            ).fetchone()
            
            last_summary_time = summary[0] if summary else None
            
            if last_summary_time:
                messages = db.execute(
                    "SELECT role, content FROM messages WHERE conversation_id = ? AND created_at > ? ORDER BY created_at ASC",
                    (conversation_id, last_summary_time)
                ).fetchall()
            else:
                messages = db.execute(
                    "SELECT role, content FROM messages WHERE conversation_id = ? ORDER BY created_at ASC",
                    (conversation_id,)
                ).fetchall()
                
            return [{"role": msg[0], "content": msg[1]} for msg in messages]
    except Exception as e:
        logger.error(f"‚ùå Failed to get unsummarized messages: {str(e)}")
        return []
